// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ChatMsg.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ChatMsg.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChatMsgRoot

@implementation ChatMsgRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ChatMsgRoot_FileDescriptor

static GPBFileDescriptor *ChatMsgRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.gx181.iChat.msg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum ClientType

GPBEnumDescriptor *ClientType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Android\000Ios\000Web\000Pc\000Other\000";
    static const int32_t values[] = {
        ClientType_Android,
        ClientType_Ios,
        ClientType_Web,
        ClientType_Pc,
        ClientType_Other,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientType_Android:
    case ClientType_Ios:
    case ClientType_Web:
    case ClientType_Pc:
    case ClientType_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageType

GPBEnumDescriptor *MessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Heart\000Login\000Loginres\000Logout\000Onlineusers\000"
        "Onlineusersres\000Chatmsg\000Chatmsgres\000Videoi"
        "nvite\000Videoinviteres\000Unreadmsg\000Unreadmsg"
        "res\000Getunreadmsg\000Getunreadmsgres\000Hismsg\000"
        "Hismsgres\000Creategroup\000Creategroupres\000Del"
        "group\000Delgroupres\000Getgroups\000Getgroupsres"
        "\000Getgroupusers\000Getgroupusersres\000";
    static const int32_t values[] = {
        MessageType_Heart,
        MessageType_Login,
        MessageType_Loginres,
        MessageType_Logout,
        MessageType_Onlineusers,
        MessageType_Onlineusersres,
        MessageType_Chatmsg,
        MessageType_Chatmsgres,
        MessageType_Videoinvite,
        MessageType_Videoinviteres,
        MessageType_Unreadmsg,
        MessageType_Unreadmsgres,
        MessageType_Getunreadmsg,
        MessageType_Getunreadmsgres,
        MessageType_Hismsg,
        MessageType_Hismsgres,
        MessageType_Creategroup,
        MessageType_Creategroupres,
        MessageType_Delgroup,
        MessageType_Delgroupres,
        MessageType_Getgroups,
        MessageType_Getgroupsres,
        MessageType_Getgroupusers,
        MessageType_Getgroupusersres,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageType_Heart:
    case MessageType_Login:
    case MessageType_Loginres:
    case MessageType_Logout:
    case MessageType_Onlineusers:
    case MessageType_Onlineusersres:
    case MessageType_Chatmsg:
    case MessageType_Chatmsgres:
    case MessageType_Videoinvite:
    case MessageType_Videoinviteres:
    case MessageType_Unreadmsg:
    case MessageType_Unreadmsgres:
    case MessageType_Getunreadmsg:
    case MessageType_Getunreadmsgres:
    case MessageType_Hismsg:
    case MessageType_Hismsgres:
    case MessageType_Creategroup:
    case MessageType_Creategroupres:
    case MessageType_Delgroup:
    case MessageType_Delgroupres:
    case MessageType_Getgroups:
    case MessageType_Getgroupsres:
    case MessageType_Getgroupusers:
    case MessageType_Getgroupusersres:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChatMessage

@implementation ChatMessage

@dynamic hasToken, token;
@dynamic hasCType, cType;
@dynamic hasMsgType, msgType;
@dynamic hasMsgPayload, msgPayload;
@dynamic hasExtradata, extradata;

typedef struct ChatMessage__storage_ {
  uint32_t _has_storage_[1];
  ClientType cType;
  MessageType msgType;
  NSString *token;
  MessageContent *msgPayload;
  NSString *extradata;
} ChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "token",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ChatMessage_FieldNumber_Token,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ChatMessage__storage_, token),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ClientType_Android,
        .core.name = "cType",
        .core.dataTypeSpecific.enumDescFunc = ClientType_EnumDescriptor,
        .core.number = ChatMessage_FieldNumber_CType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ChatMessage__storage_, cType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = MessageType_Heart,
        .core.name = "msgType",
        .core.dataTypeSpecific.enumDescFunc = MessageType_EnumDescriptor,
        .core.number = ChatMessage_FieldNumber_MsgType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ChatMessage__storage_, msgType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "msgPayload",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageContent),
        .core.number = ChatMessage_FieldNumber_MsgPayload,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ChatMessage__storage_, msgPayload),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "extradata",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ChatMessage_FieldNumber_Extradata,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ChatMessage__storage_, extradata),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatMessage class]
                                     rootClass:[ChatMsgRoot class]
                                          file:ChatMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\005\000\003\007\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageContent

@implementation MessageContent

@dynamic hasContent, content;
@dynamic hasOccureTime, occureTime;
@dynamic hasSpeakerId, speakerId;
@dynamic hasAudienceId, audienceId;
@dynamic hasIsGroupChat, isGroupChat;
@dynamic filesArray, filesArray_Count;

typedef struct MessageContent__storage_ {
  uint32_t _has_storage_[1];
  int32_t isGroupChat;
  NSString *content;
  NSString *speakerId;
  NSString *audienceId;
  NSMutableArray *filesArray;
  uint64_t occureTime;
} MessageContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageContent__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "occureTime",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_OccureTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, occureTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "speakerId",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_SpeakerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageContent__storage_, speakerId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "audienceId",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_AudienceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageContent__storage_, audienceId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isGroupChat",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_IsGroupChat,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageContent__storage_, isGroupChat),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "filesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FileInfo),
        .number = MessageContent_FieldNumber_FilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageContent__storage_, filesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageContent class]
                                     rootClass:[ChatMsgRoot class]
                                          file:ChatMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\n\000\003\t\000\004\n\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileInfo

@implementation FileInfo

@dynamic hasFileName, fileName;
@dynamic hasFilePayLoad, filePayLoad;
@dynamic hasDesc, desc;
@dynamic hasExtradata, extradata;

typedef struct FileInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileName;
  NSData *filePayLoad;
  NSString *desc;
  NSString *extradata;
} FileInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = FileInfo_FieldNumber_FileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileInfo__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "filePayLoad",
        .dataTypeSpecific.className = NULL,
        .number = FileInfo_FieldNumber_FilePayLoad,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileInfo__storage_, filePayLoad),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = FileInfo_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FileInfo__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extradata",
        .dataTypeSpecific.className = NULL,
        .number = FileInfo_FieldNumber_Extradata,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FileInfo__storage_, extradata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileInfo class]
                                     rootClass:[ChatMsgRoot class]
                                          file:ChatMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
